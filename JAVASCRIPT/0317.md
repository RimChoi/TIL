## 함수와 메소드
+ 함수와 메소드 구분
    + **함수**: 오브젝트에 연결 **(인스턴스 생성시 호출 x)**
        + ex: Object.create
    + **메소드**: 오브젝트.prototype에 연결 **(인스턴스 생성시 호출 o)**
        + ex: Object.prototype.toString
+ 호출 방법
    + 함수: Object.create()
    + 메소드: Object.prototype.toString()
    + 또는 인스턴스를 생성하여 인스턴스.toString()


### toString()
+ 개요
    + ***인스턴스 타입*** 을 문자열 표시 형태로 변환하여 변환
+ 작성방법
    + 파라미터에 값 작성 불가
    + object 위치에 오브젝트가 아닌 인스턴스 작성

| 구분     | 타입     | 데이터(값) |
|----------|----------|------------|
| Object   | Instance | 변환 대상  |
| 파라미터 | Any      | 사용 불가  |
| 반환     | String   | 변환 결과  |

+ toString() 메커니즘
    1. 대부분의     빌트인 오브젝트에 toString()이 있음
    2. 모든 인스턴스에 Object.prototype.toString() 이 설정됨
    3. 오브젝트에 toString() 이 있으면 오브젝트의 toString()이 호출되고
    4. 없으면 Object의 toString()이 호출됨

> toLocaleString()

```javascript
/**
 * 1. Object() 생성자 함수코드가 출력된 것은
 * 2. toString() 앞에 작성한 인스턴스를 작성하지않고
 * - Object를 작성했으므로 Object.toString()이 호출되며
 * 3. Object 전체를 참조하는 생성자 함수 코드가 출력된다.
 */

console.log(Object.toString());

/**
 * 1. Object 인스턴스생성 => 생성 인스턴스로 toString() 호출
 * [object Object] 출력
 */
var obj = new Object();
console.log(obj.toString());

/**
 * 1. Number 인스턴스 생성 
 * 2. Object 인스턴스가 아닌 Number 인스턴스의 toString() 호출
 * 3. Number 인스턴스의 프리미티브 값을 문자열로 변환하여 반환
 */
var newObj = new Number(12);
console.log(newObj.toString());


/**
 * 1. Array도 Number와 변환 방법이 같음
 */
newObj = new Array(12, 34);
console.log(newObj.toString());

123.toString(); //Err

value = 123;
console.log(value.toString()); // "123"

/**
 * (1+2+3)은 표현식으로 표현식 평가 결과인 6을 사용
 */
console.log((1+2+3).toString());
```

### valueOf()

+ 개요
    1. 오브젝트의 프리미티브 값 반환
    2. 프리미티브 값을 반환하는 오브젝트
        + boolean, Date, Number, String Object
    3. 4개 오브젝트는 자신의 valueOf()가 호출되고
        + 다른 오브젝트는 Object.prototype.valueOf()가 호출된다.
    4. Object는 프리미티브 값이 없으므로 인스턴스 타입을 문자열로 반환
+ 작성방법
    + object 위치에 오브젝트가 아닌 인스턴스 작성

| 구분     | 타입     | 데이터(값)    |
|----------|----------|---------------|
| object   | Instance | 대상 인스턴스 |
| 파라미터 | Any      | 사용 불가     |
| 반환     | String   | 변환 결과     |


```javascript
/**
 * 1. Number 인스턴스는 자체에 valueOf()를 갖고 있으므로
 * 2. Number.prototype.valueOf()가 호출되며 프리미티브 값을 반환한다.
 */
new Number(123).valueOf();


/**
 * 1. Object 오브젝트는 프리미티브 값을 제공하지 않으므로
 *  - 생성한 인스턴스를 문자열로 변환하여 반환한다.
 */
new Object().valueOf();
```

### hasOwnProperty()
+ 개요
    + 인스턴스 소유의 프로퍼티 존재 여부 반환
    + 인스턴스에 파라미터에 작성한 이름이 존재: true 반환 / 존재x: false 반환
    + 자신이 만든것이 아니라 상속받은 프로퍼티 이면 false 반환
+ 작성방법
    + object 위치에 오브젝트가 아닌 인스턴스작성
    + 파라미터를 문자열로 변환하여 체크하므로 숫자 작성 가능

| 구분     | 타입     | 데이터(값)    |
|----------|----------|---------------|
| object   | Instance | 기준 인스턴스 |
| 파라미터 | String   | 프로퍼티 이름 |
| 반환     | Boolean  | true, false   |

> for..in / key: value 값을 가져오고싶은데 .. / prototype 연결 값이 들어올때가있다..
구분하고 싶을때 종종 쓰기도 함.


```javascript
/**
 * 1. 생성한 인스턴스에 프로퍼티 이름(value)과 값(123)을 설정한다.
 */
var obj = new Object();
obj.value = 123;

/**
 * 1. 인스턴스에 직접 value 프로퍼티 설정 했으므로
 * => 자신이 작성한 것이되어 true 반환
 */
obj.hasOwnProperty('value');

/**
 * 1. 갑은 체크하지 않고
 *  프로퍼티의 존재 여부만 체크하므로 true 반환
 */
obj.undef = undefined;
obj.hasOwnProperty('undef');

/**
 * 1. obj는 Object.prototype에
 *  - 연결된 메소드로 생성한 인스턴스
 * 
 * 2. hasOwnProperty()는 자신이 작성한 것이 아니라
 *  - Object.prototype에 작성된 것이므로 false 반환
 */
obj.hasOwnProperty('hasOwnProperty');
```


### Object.prototype 상속

```javascript
/**
 * 1. Number 인스턴스를 생성하고
 * 2. 인스턴스의 value 프로퍼티에 123을 할당한다.
 */

var obj = new Number();
obj.value = 123;
console.log(obj.value);

/**
 * 1. 브라우저 디버깅 창에서 hasOwnProperty()가
 *  - Number 인스턴스(obj)에 존재하지 않고
 *  - _proto_에 존재하는 것을 확인한다.
 * 
 * 2. Number 오브젝트에 hasOwnProperty
 *  - 에러가 발생하지 않고 호출이 되는것은
 *  - Object 오브젝트에 있는 hasOwnProperty()가 호출되기 때문
 * 
 * 3. Object 오브젝트의 메소드가 호출될 수 있는 것은
 *  - 모든 오브젝트에 Object.property의 6개 메소드가 상속되기 때문이다.
 * 
 * 4. 상속된 메소드는 _proto_에 설정된다.
 */
var result = obj.hasOwnProperty('value');
console.log(result);

```

### prototype chain
+ 개요
    + prototype에 오브젝트를 연결하고
        + 연결된 오브젝트의 prototype에 다시 오브젝트를 연결
    + 따라서 3개의 오브젝트가 연결된 형태가 된다.
    + 이 형태를 prototype chain 이라고 함
+ 연결
    + 함수 이름을 키로 하여 prototype에 연결한 형태
    + function sports(){};
    + Sports.prototype["baseball"] = function(){};
+ 상속
    + 오브젝트의 orototype에 연결된 프로퍼티를
    + 인스턴스로 생성하여 연결한 형태
    + function soccer(){};
    + Sports.prototype = new Soccer();


```javascript
    
```

## Comment
1. 시나리오를 작성하라.(요구사항)
    1-1.  요구사항에 맞춰 flow 에 맞춰 어떤 기술을 사용할 것인가
    1-2. 치트시트를 빠르게 훑어 보자
